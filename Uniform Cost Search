from queue import PriorityQueue

class Node:
    def __init__(self, name, parent=None, action=None, cost=0):
        self.name = name
        self.parent = parent
        self.action = action
        self.cost = cost
    
    def __lt__(self, other):
        return self.cost < other.cost

def uniform_cost_search(problem):
    start_node = Node(problem.initial_node)
    frontier = PriorityQueue()
    frontier.put(start_node)
    explored = set()

    while not frontier.empty():
        node = frontier.get()
        if problem.goal_test(node.name):
            return get_solution(node)
        
        explored.add(node.name)

        for action in problem.get_actions(node.name):
            child_node_name = problem.get_result(node.name, action)
            child_cost = node.cost + problem.get_cost(node.name, child_node_name)
            child_node = Node(child_node_name, node, action, child_cost)

            if child_node_name not in explored and not_in_frontier(frontier, child_node_name):
                frontier.put(child_node)
            elif not_in_frontier(frontier, child_node_name):
                replace_frontier_node(frontier, child_node)
    
    return None

def get_solution(node):
    solution = []
    while node.parent is not None:
        solution.append((node.name, node.action))
        node = node.parent
    solution.reverse()
    return solution

def not_in_frontier(frontier, node_name):
    for node in frontier.queue:
        if node.name == node_name:
            return False
    return True

def replace_frontier_node(frontier, new_node):
    for i, node in enumerate(frontier.queue):
        if node.name == new_node.name and node.cost > new_node.cost:
            frontier.queue[i] = new_node
            break

class Problem:
    def __init__(self, initial_node, goal_node, nodes, costs):
        self.initial_node = initial_node
        self.goal_node = goal_node
        self.nodes = nodes
        self.costs = costs
    
    def goal_test(self, node_name):
        return node_name == self.goal_node
    
    def get_actions(self, node_name):
        actions = []
        for i, node in enumerate(self.nodes):
            if node == node_name:
                actions.append(i)
        return actions
    
    def get_result(self, node_name, action):
        return self.nodes[action]
    
    def get_cost(self, node_name, child_node_name):
        index1 = self.nodes.index(node_name)
        index2 = self.nodes.index(child_node_name)
        return self.costs[index1][index2]

# Get user input for nodes and costs
num_nodes = int(input("Enter the number of nodes: "))
nodes = []
costs = []

for i in range(num_nodes):
    node = input(f"Enter node {i+1}: ")
    nodes.append(node)

for i in range(num_nodes):
    row = []
    for j in range(num_nodes):
        cost = int(input(f"Enter cost from node {nodes[i]} to node {nodes[j]}: "))
        row.append(cost)
    costs.append(row)

initial_node = input("Enter the initial node: ")
goal_node = input("Enter the goal node: ")

# Create an instance of the problem
problem = Problem(initial_node, goal_node, nodes, costs)

# Run the Uniform Cost Search algorithm
solution = uniform_cost_search(problem)


Print the solution path
if solution is not None:
    print("Solution:")
    for node, action in solution:
        print(f"Node: {node}, Action: {action}")
else:
    print("No solution found.")
